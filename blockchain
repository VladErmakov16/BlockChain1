import hashlib
import datetime
import time
from hashlib import sha256
from Crypto.PublicKey import ECC
from Crypto.Signature import DSS
from Crypto.Hash import SHA256
# from Crypto.Random import random  # для случайного выбора майнера
# todo: заменить буржуйскую крипту на госты


# параметры системы
INITIAL_COINBASE_AMOUNT = 1000000
MINING_DIFFICULTY = 10
BLOCK_REWARD = 5

# значения для читаемого вывода
TAB2 = '\t' * 2
TAB3 = '\t' * 3
TAB4 = '\t' * 4
TAB5 = '\t' * 5
TAB6 = '\t' * 6
LEFT_P = '{'
RIGHT_P = '}'


def calculate_merkle_root(data_list: list):
    """Вычисление корня древа Меркла"""
    leaf_hashes = [leaf.calculate_hash() for leaf in data_list]

    while len(leaf_hashes) > 1:
        new_leaf_hashes = []

        for i in range(0, len(leaf_hashes), 2):
            if i + 1 >= len(leaf_hashes):
                leaf_hashes.append(leaf_hashes[i])

            combined_hash = hashlib.sha256((leaf_hashes[i] + leaf_hashes[i + 1]).encode()).hexdigest()
            new_leaf_hashes.append(combined_hash)

        leaf_hashes = new_leaf_hashes

    return leaf_hashes[0]


class Transaction:
    def __init__(self, inputs: list[dict[str, int]], outputs: list[dict[str, int]], signature: hex, public_key: hex):
        """Инициализация транзакции"""
        self.inputs = inputs
        self.outputs = outputs
        self.signature = signature
        self.public_key = public_key

    def calculate_hash(self):
        """Вычисление хеш-кода блока"""
        transaction_str = f"{self.inputs}{self.outputs}{self.signature}{self.public_key}"
        return hashlib.sha256(transaction_str.encode()).hexdigest()

    def __repr__(self):
        """Вывод транзакции в читаемом виде"""
        res = [f'\n{TAB4}{LEFT_P}\n{TAB5}Входы транзакции:']
        for i, inp in enumerate(self.inputs, 1):
            res.append(f'{TAB6}Вход {i}\n{TAB6}{str(inp)}')

        res.append(f'{TAB5}Выходы транзакции:')
        for i, out in enumerate(self.outputs, 1):
            res.append(f'{TAB6}Выход {i}\n{TAB6}{str(out)}')

        res.append(f'{TAB5}Подпись: {self.signature}')
        res.append(f'{TAB5}Открытый ключ: {self.public_key}')
        res.append(f'{TAB4}{RIGHT_P}\n')
        return '\n'.join(res)


class Block:
    def __init__(self, height: int, prev_hash: hex, coinbase: int, transactions: list[Transaction]):
        """Инициализация блока"""
        self.height = height
        self.time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.merkle_root = 0x0
        self.prev_hash = prev_hash
        self.nonce = 0
        self.hash = None

        self.coinbase = coinbase
        self.transactions = transactions

    def mine(self):
        """Добыча блока"""
        target = 2 ** (256 - MINING_DIFFICULTY)
        self.hash = self.calculate_hash()
        while int(self.hash, 16) >= target:
            self.nonce += 1
            self.hash = self.calculate_hash()

    def calculate_hash(self):
        """Вычисление хеш-кода блока"""
        block_str = f"{self.height}{self.time}{self.prev_hash}{self.coinbase}{self.nonce}"
        return hashlib.sha256(block_str.encode()).hexdigest()

    def __repr__(self):
        """Вывод блока в читаемом виде"""
        res = [f'\n\t{LEFT_P}\n{TAB2}Заголовок блока:',
               f'{TAB3}Номер блока: {self.height}',
               f'{TAB3}Дата и время создания: {self.time}',
               f'{TAB3}Корень древа Меркла: {self.merkle_root}',
               f'{TAB3}Хеш-код предыдущего блока: {self.prev_hash}',
               f'{TAB3}Nonce: {self.nonce}',
               f'{TAB3}Хеш-код текущего блока: {self.hash}',
               F'{TAB2}Тело блока:',
               f'{TAB3}Coinbase: {self.coinbase}',
               f'{TAB3}Транзакции:']

        for i, tx in enumerate(self.transactions, 1):
            res.append(f'{TAB4}Транзакция {i}{tx}')
        res.append(f'\t{RIGHT_P}\n')

        return '\n'.join(res)


class Client:
    def __init__(self, name: str):
        """Инициализация клиента"""
        self.name = name
        self.sk = ECC.generate(curve='P-256')
        self.pk = self.sk.public_key()
        self.address = sha256(self.pk.export_key(format='DER')).hexdigest()
        self.utxo = []
        self.balance = 0

    def create_transaction(self, inputs: list[dict[str, int]], outputs: list[dict[str, int]]):
        """Создание транзакции"""
        transaction = Transaction(inputs, outputs, None, self.pk.export_key(format='DER').hex())

        message = ""
        for transaction_input in inputs:
            message += str(transaction_input['input_address']) + str(transaction_input['input_amount'])
        for transaction_output in outputs:
            message += str(transaction_output['output_address']) + str(transaction_output['output_amount'])

        h = SHA256.new(message.encode())
        signer = DSS.new(self.sk, 'fips-186-3')
        signature = signer.sign(h)
        transaction.signature = signature.hex()

        return transaction

    def read_transaction(self, block: Block):
        """Чтение транзакции"""
        for transaction in block.transactions:
            for transaction_input in transaction.inputs:
                utxo = {'address': transaction_input['input_address'], 'amount': transaction_input['input_amount']}
                if utxo["address"] == self.address:
                    self.utxo.remove(utxo)
                    self.balance -= utxo["amount"]

            for transaction_output in transaction.outputs:
                utxo = {'address': transaction_output['output_address'], 'amount': transaction_output['output_amount']}
                if utxo["address"] == self.address:
                    self.utxo.append(utxo)
                    self.balance += utxo["amount"]

    def get_balance(self):
        """Получение текущего баланса пользователя"""
        return self.balance


class Node:
    def __init__(self, node_id: int, client: Client):
        """Инициализация узла сети"""
        self.node_id = node_id
        self.chain = []
        self.utxo = [{'address': 0x0, 'amount': INITIAL_COINBASE_AMOUNT}]  # список UTXO
        self.miner = client
        self.current_transactions = []

    def create_genesis_block(self):
        """Создание генезис-блока"""
        miner_transaction = self.create_miner_transaction()
        genesis_block = Block(0, 0x0, INITIAL_COINBASE_AMOUNT, [miner_transaction])
        genesis_block.mine()
        self.finalize_block(genesis_block)
        self.chain.append(genesis_block)
        return genesis_block

    def mine_block(self):
        """Добыча блока"""
        miner_transaction = self.create_miner_transaction()
        self.current_transactions.insert(0, miner_transaction)

        new_block = Block(len(self.chain),
                          self.chain[-1].hash,
                          self.chain[-1].coinbase - BLOCK_REWARD,
                          self.current_transactions)
        new_block.merkle_root = calculate_merkle_root(new_block.transactions)
        new_block.mine()

        # финализация блока
        self.finalize_block(new_block)
        self.chain.append(new_block)
        # рассылка нового блока остальным нодам
        self.current_transactions = []
        return new_block

    def create_miner_transaction(self):
        """Создание транзакции, в которой выплачивается вознаграждение майнеру"""
        miner_inputs = [
            {
                'input_address': 0x0,
                'input_amount': self.chain[-1].coinbase - BLOCK_REWARD if len(self.chain) > 0 else INITIAL_COINBASE_AMOUNT
            }
        ]
        miner_outputs = [
            {
                'output_address': self.miner.address,
                'output_amount': BLOCK_REWARD
            },
            {
                'output_address': 0x0,
                'output_amount': self.chain[-1].coinbase - 2 * BLOCK_REWARD if len(self.chain) > 0 else INITIAL_COINBASE_AMOUNT - BLOCK_REWARD
            }
        ]
        return Transaction(inputs=miner_inputs, outputs=miner_outputs, signature=0x0, public_key=0x0)

    def add_transactions(self, transactions):
        """Добавление транзакций в мемпул"""
        self.current_transactions.extend(transactions)

    def finalize_block(self, block):
        """Обновление utxo"""
        # исключение input_UTXO каждой транзакции из своего списка UTXO
        for transaction in block.transactions:
            for transaction_input in transaction.inputs:
                utxo = {'address': transaction_input['input_address'],
                         'amount': transaction_input['input_amount']}
                if utxo in self.utxo:
                    self.utxo.remove(utxo)
                else:
                    print('Ошибка. Повторная трата монет')
                    return -1

        # добавление output_UTXO каждой транзакции в свой список UTXO
        for transaction in block.transactions:
            for transaction_output in transaction.outputs:
                utxo = {'address': transaction_output['output_address'],
                        'amount': transaction_output['output_amount']}
                self.utxo.append(utxo)

    def receive_block(self, block):
        """Получение блока от другого узла сети"""
        if len(self.chain) == 0:
            self.finalize_block(block)
            self.chain.append(block)
            return
        is_block_valid = self.validate_block(block)
        if is_block_valid:
            print('Заебись')
        else:
            print('Не заебись:(')

    def validate_block(self, block):
        """Проверка валидности блока"""
        # 1) Пересчет дерева Меркла и сравнение корневого хэш-кода
        merkle_root = calculate_merkle_root(block.transactions)
        if merkle_root != block.merkle_root:
            print('Не заебись 1:(')
            return False

        # 2) Проверка правильности решения майнером
        target = 2 ** (256 - MINING_DIFFICULTY)
        block_hash = block.calculate_hash()
        if int(block_hash, 16) >= target:
            print('Не заебись 2:(')
            return False

        # 3) Проверка номера блока
        if block.height != len(self.chain):
            print('Не заебись 3:(')
            return False

        # 4) Проверка хэш-кода предыдущего блока
        if block.height > 0 and block.prev_hash != self.chain[-1].hash:
            print(block.prev_hash, self.chain[-1].hash)
            print('Не заебись 4:(')
            return False

        # 5) Проверка времени создания блока
        if block.height > 0 and block.time <= self.chain[-1].time:
            print('Не заебись 5:(')
            return False

        # 6) Проверка значения coinbase
        if block.coinbase <= 0 or block.coinbase != self.chain[-1].coinbase - BLOCK_REWARD:
            print('Не заебись 6:(')
            return False

        # 7) Проверка UTXO транзакций
        for transaction in block.transactions:
            for transaction_input in transaction.inputs:
                utxo = {'address': transaction_input['input_address'], 'amount': transaction_input['input_amount']}
                if utxo not in self.utxo:
                    print(utxo, self.utxo)
                    print('Не заебись 7:(')
                    return False

        # 8) Проверка суммы входов и выходов транзакций
        for transaction in block.transactions:
            input_sum = sum(transaction_input['input_amount'] for transaction_input in transaction.inputs)
            output_sum = sum(transaction_output['output_amount'] for transaction_output in transaction.outputs)
            if input_sum < output_sum:
                print('Не заебись 8:(')
                return False

        # 9) Проверка цифровых подписей
#        for transaction in block.transactions:
#            if not self.verify_transaction_signature(transaction):
#                print('Проверка цифровых подписей провалилась')
#                return False
        # (Для упрощения считаем, что все подписи верны)
        # todo: check transactions signatures

        # utxo обновляются здесь
        #print(self.utxo)
        self.finalize_block(block)
        #print(self.utxo)

        # все проверки пройдены успешно, включаем блок в цепочку
        self.chain.append(block)
        return True

def update_balances(clients, block):
    for client in clients:
        client.read_transaction(block)
        print(client.get_balance())

def normal():
    # кайфовый сценарий
    # создание клиентов и нод
    client1 = Client('Alice')
    client2 = Client('Dima')
    client3 = Client('Vlad')
    client4 = Client('Anton')
    clients = [client1, client2, client3, client4]
    node1 = Node(1, client1)
    node2 = Node(2, client2)
    node3 = Node(3, client3)
    nodes = [node1, node2, node3]

    # genesis block
    miner_node = 0
    print(nodes[0].utxo)
    current_block = nodes[miner_node].create_genesis_block()
    nodes[2].receive_block(current_block)
    nodes[1].receive_block(current_block)
    print(nodes[0].utxo)
    print(nodes[1].utxo)
    update_balances(clients, current_block)
    time.sleep(1)

    # 1 block
    miner_node = 0
    #todo: майнер должен отправить деревянные client4 (пусть будет 3 монеты, 2 переведёт себе)
    #создать соответствующую транзакцию
    client_inputs = [
       {
           'input_address': client1.address,
           'input_amount': 5
       }
    ]
    client_outputs = [
       {
           'output_address': client1.address,
           'output_amount': 2
       },
       {
           'output_address': client4.address,
           'output_amount': 3
       }
    ]
    tx = client1.create_transaction(client_inputs, client_outputs)
    nodes[1].add_transactions([tx])
    current_block = nodes[1].mine_block()
    nodes[0].receive_block(current_block)
    nodes[2].receive_block(current_block)
    print(nodes[0].utxo)
    print(nodes[1].utxo)

    update_balances(clients, current_block)
    # 2 block
    time.sleep(1)
    client_inputs = [
       {
           'input_address': client4.address,
           'input_amount': 3
       }
    ]
    client_outputs = [
       {
           'output_address': client4.address,
           'output_amount': 1
       },
       {
           'output_address': client2.address,
           'output_amount': 2
       }
    ]
    tx = client1.create_transaction(client_inputs, client_outputs)
    nodes[2].add_transactions([tx])
    current_block = nodes[2].mine_block()
    nodes[0].receive_block(current_block)
    nodes[1].receive_block(current_block)
    update_balances(clients, current_block)
    print(nodes[2].chain)

def bad():
    client1 = Client('Alice')
    client2 = Client('Dima')
    client3 = Client('Vlad')
    client4 = Client('Anton')
    clients = [client1, client2, client3, client4]
    node1 = Node(1, client1)
    node2 = Node(2, client2)
    node3 = Node(3, client3)
    nodes = [node1, node2, node3]
    # плохой сценарий
    # todo: 1. нода, выбранная лидером и формирующая новый блок, обнаруживает попытку клиента повторно потратить UTXO,
    #  который уже есть в её списке UTXO;
    # genesis block
    miner_node = 0
    print(nodes[0].utxo)
    current_block = nodes[miner_node].create_genesis_block()
    nodes[2].receive_block(current_block)
    nodes[1].receive_block(current_block)
    update_balances(clients, current_block)
    time.sleep(1)

    # 1 block
    miner_node = 0
    #todo: майнер должен отправить деревянные client4 (пусть будет 3 монеты, 2 переведёт себе)
    #создать соответствующую транзакцию
    client_inputs = [
       {
           'input_address': client1.address,
           'input_amount': 5
       }
    ]
    client_outputs = [
       {
           'output_address': client1.address,
           'output_amount': 2
       },
       {
           'output_address': client4.address,
           'output_amount': 3
       }
    ]
    tx = client1.create_transaction(client_inputs, client_outputs)
    nodes[1].add_transactions([tx, tx])
    current_block = nodes[1].mine_block()
    print('Просто строка')
    nodes[0].receive_block(current_block)
    print('Просто вторая строка')
    nodes[2].receive_block(current_block)
    update_balances(clients, nodes[2].chain[-1])
    # todo: 2. нода, получающая новый блок от другой ноды, обнаруживает ошибки при проверке условий 1) – 10) (внесём
    #  ошибку в хеш блока)
    # todo: 3. клиент пытается создать транзакцию, у которой сумма output_UTXO превышает баланс его криптокошелька.

# Пример использования
if __name__ == '__main__':
    #normal()
    bad()
